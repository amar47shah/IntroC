void getTwoFloats (float *, float *);
void getTwoIntegers (int *, int *);


void getTwoFloats (float *fTheFirst, float *fTheSecond) {
    printf ("Enter the first number: ");
    scanf ("%f", fTheFirst);
    printf ("Enter the second number: ");
    scanf ("%f", fTheSecond);
}
void getTwoIntegers (int *iTheFirst, int *iTheSecond) {
    printf ("Enter the first number: ");
    scanf ("%d", iTheFirst);
    printf ("Enter the second number: ");
    scanf ("%d", iTheSecond);
}


                    /*  The following loop tests for primeness by calculating the successive values: iTestIfPrime mod 2, 
                     *  iTestIfPrime mod 3, iTestIfPrime mod 4, etc.  The value of iPossibleFactor is used as a counter
                     *  from 2 up to iTestIfPrime / 2 + 1. (That is, just over half of iTestIfPrime; it is not necessary 
                     *  to count any further.)  The loop terminates whenever one of the following conditions is satisfied: 
                     *  1) iTestIfPrime mod iPossibleFactor == 0 or 2) iPossibleFactor is too large.  The loop will always 
                     *  eventually terminate if iTestIfPrime has an integer value that is greater than one.
                     */
                    int iPossibleFactor = 1;
					do
                        iPossibleFactor++;	
                    while ((iPossibleFactor < iTestIfPrime / 2 + 1) && (iTestIfPrime % iPossibleFactor != 0));
                    /*  Once the loop terminates, the last value of iPossibleFactor is retained.  If iPossibleFactor's current value 
                     *  is indeed a non-trivial factor of iTestIfPrime (that is, iTestIfPrime mod iPossibleFactor == 0), then the 
                     *  primeness test has failed.  If the value of iTestIfPrime was entered as 2, it must be treated as a special 
                     *  case, so that a "Not prime" result will NOT be generated.
                     */
                    if ((iTestIfPrime % iPossibleFactor == 0) && (iTestIfPrime != 2))
                        printf ("Not prime: %d x %d = %d\n", iPossibleFactor, iTestIfPrime / iPossibleFactor, iTestIfPrime);
                    //  If an integer greater than 1 is not "Not prime", then it is prime.
                    else
                        printf ("%d is prime.\n", iTestIfPrime);
						
						switch (iOperand1) {
					    case 1:
					        printf ("The %dst Fibonacci number is %d.\n", iOperand1, iFibonacci(iOperand1));
                            break;
						case 2:
                            printf ("The %dnd Fibonacci number is %d.\n", iOperand1, iFibonacci(iOperand1));
                            break;
				        case 3:
					        printf ("The %drd Fibonacci number is %d.\n", iOperand1, iFibonacci(iOperand1));
                            break;
                        default:
					        printf ("The %dth Fibonacci number is %d.\n", iOperand1, iFibonacci(iOperand1));
					     	break;
							
Remaining tasks
1) User Friendly Input
   a) Accept only input for Operation Choice that is a single character (0-9).
      That is, delete extra input.
   b) when a number is required, don't accept non-numerical.
   c) when an integer is required, don't accept a float
2) 

        /*  Numerical variables fOperand1, fOperand2, iOperand1, and iOperand2 will be 
	     *  used to store user-entered float and integer values.  The float fResult and
		 *  integer iResult are used to store the results of calculations.  The choice
		 *  of a float variable or its integer counterpart depends on the chosen calculator
		 *  function.  For example, if the user chooses "Modulus", only the three integer 
		 *  variables (iOperand1, iOperand2, and iResult) will be used.  These six variables 
		 *  are defined here so that they are local to the do-while loop that iterates once 
		 *  per user operation.
		 */
		float fOperand1 = 0.0, fOperand2 = 0.0, fResult = 0.0;
        int iOperand1 = 0, iOperand2 = 0, iResult = 0;